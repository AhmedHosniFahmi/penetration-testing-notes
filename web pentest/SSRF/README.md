## SSRF Attacks 
- SSRF attacks against the server itself
- SSRF attacks against other back-end systems



## Exploiting SSRF vulnerabilities can lead to:
- Interacting with known internal systems
- Discovering internal services via port scans
- Disclosing local/sensitive data
- Including files in the target application
- Leaking NetNTLM hashes using UNC Paths (Windows)
- Achieving remote code execution


## When hunting for SSRF vulnerabilities, we should `look for` OR `fuzz`:
- Parts of HTTP requests, including URLs
- File imports such as HTML, PDFs, images, etc.
- Remote server connections to fetch data
- API specification imports
- Dashboards including ping and similar functionalities to check server statuses


## Testing if app vulnerable to SSRF
### Test interacting with outif 




## SSRF with blacklist-based input filters

- Using an alternative IP representation of 127.0.0.1, such as 2130706433, 017700000001, or 127.1.
- Registering your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose.
- Obfuscating blocked strings using URL encoding or case variation.
- Providing a URL that you control, which subsequently redirects to the target URL. Try using different redirect codes, as well as different protocols for the target URL.


## SSRF with whitelist-based input filters

- You can embed credentials in a URL before the hostname, using the @ character. For example:
```bash
https://expected-host:fakepassword@evil-host
```
- You can use the # character to indicate a URL fragment. For example:
```bash
https://evil-host#expected-host
```
- You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:
```bash
https://expected-host.evil-host
```
- You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
```text
Note
that you can also try double-encoding characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.
```
- You can use combinations of these techniques together.

